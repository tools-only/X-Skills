---
name: ai-response-refiner
description: AI応答を洗練・改善するスキル。粗い出力を流暢で専門的な文章に変換。構造化、明確化、詳細化、トーン調整、専門性向上、読みやすさ改善を実施。
---

# AI Response Refiner Skill

AIが生成した粗い出力を洗練された高品質な応答に改善するスキルです。

## 概要

このスキルは、AIの初期出力を多角的に改善し、より洗練された応答に変換します。文章の流暢性、専門性、明確性、構造、読みやすさを向上させ、対象読者やコンテキストに最適化します。

## 主な機能

- **文章の流暢性向上**: 自然で読みやすい文章に改善
- **構造化**: 論理的な構成と見出しの追加
- **明確化**: 曖昧な表現を具体的に
- **詳細化**: 不足している情報を補完
- **簡潔化**: 冗長な部分を削除
- **トーン調整**: フォーマル、カジュアル、技術的等に調整
- **専門性向上**: 技術的な正確性と深さを改善
- **読みやすさ改善**: 段落分割、箇条書き、コード例の追加
- **例の追加**: 具体例、コードスニペット、図表の提案
- **対象読者最適化**: 初心者、中級者、上級者向けに調整

## 改善パターン

### 1. 文章の流暢性向上

#### Before: ぎこちない文章

```
AI初期出力:
「Reactです。コンポーネントベースです。再利用できます。
JavaScriptライブラリです。UIを作ります。」
```

#### After: 流暢な文章

```
改善版:
「Reactは、再利用可能なコンポーネントベースでUIを構築できる
JavaScriptライブラリです。各コンポーネントは独立した機能を持ち、
複雑なユーザーインターフェースを効率的に開発できます。」
```

**改善ポイント**:
- 短文を結合して自然な流れに
- 接続詞の適切な使用
- 文章のリズムと読みやすさの向上

### 2. 構造化

#### Before: 非構造化

```
AI初期出力:
「TypeScriptは型があります。JavaScriptのスーパーセットです。
コンパイルが必要です。エラーを早期に発見できます。大規模開発に向いています。
IDEのサポートが良いです。」
```

#### After: 構造化

```
改善版:
# TypeScriptの特徴

## 概要
TypeScriptは、JavaScriptにオプショナルな型システムを追加した
スーパーセット言語です。

## 主な特徴

### 1. 静的型付け
- コンパイル時に型チェックを実施
- 実行前にエラーを発見可能

### 2. 開発体験の向上
- IDEによる強力な補完機能
- リファクタリングの安全性向上

### 3. スケーラビリティ
- 大規模プロジェクトに最適
- チーム開発での生産性向上
```

**改善ポイント**:
- 見出しによる階層構造
- トピックごとの整理
- 箇条書きで要点を明確に

### 3. 明確化

#### Before: 曖昧

```
AI初期出力:
「このメソッドはデータを処理します。いくつかの変換を行い、
結果を返します。」
```

#### After: 明確

```
改善版:
「この`processData()`メソッドは、以下の処理を実行します：

1. 入力データのバリデーション
2. 数値データの正規化（0-1の範囲に変換）
3. 欠損値の補完（平均値で埋める）
4. 処理済みデータの配列を返却

**入力**: 数値の配列
**出力**: 正規化された数値の配列
**例外**: データが空の場合、`EmptyDataError`をスロー
```

**改善ポイント**:
- 具体的な処理内容を明記
- 入出力を明確に
- 例外ケースも記載

### 4. 詳細化

#### Before: 不完全

```
AI初期出力:
「Dockerを使ってください。」
```

#### After: 詳細

```
改善版:
# Dockerの導入手順

## 1. Dockerのインストール

### Windows
1. Docker Desktopをダウンロード
2. インストーラーを実行
3. WSL 2を有効化（Windows 10/11の場合）

### macOS
```bash
brew install --cask docker
```

### Linux (Ubuntu)
```bash
sudo apt update
sudo apt install docker.io
sudo systemctl start docker
sudo systemctl enable docker
```

## 2. Dockerイメージの作成

Dockerfileを作成:
```dockerfile
FROM node:18-alpine
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
CMD ["npm", "start"]
```

## 3. イメージのビルドと実行

```bash
# イメージビルド
docker build -t myapp:1.0 .

# コンテナ起動
docker run -p 3000:3000 myapp:1.0
```

## トラブルシューティング

- **ポートが使用中**: `-p` で別のポートを指定
- **権限エラー**: `sudo`を追加、またはユーザーをdockerグループに追加
```

**改善ポイント**:
- 具体的な手順を追加
- コード例の提供
- トラブルシューティング情報を含める

### 5. 簡潔化

#### Before: 冗長

```
AI初期出力:
「このアルゴリズムは、まず最初に配列の各要素を順番に走査していきます。
そして、走査している過程で各要素を確認して、その要素が条件を満たしているか
どうかをチェックします。もし条件を満たしている場合には、その要素を
新しい配列に追加していきます。このような処理を配列の最後の要素まで
繰り返し続けます。最終的に、条件を満たした要素だけが格納された
新しい配列が得られます。」
```

#### After: 簡潔

```
改善版:
「このアルゴリズムは、配列の各要素を走査し、条件を満たす要素のみを
抽出して新しい配列を生成します。

```javascript
const filtered = array.filter(element => element > 10);
```

つまり、`Array.filter()`メソッドと同等の処理です。」
```

**改善ポイント**:
- 冗長な説明を削除
- コード例で直感的に理解
- 1-2文に要約

### 6. トーン調整

#### フォーマル（ビジネス文書）

```
AI初期出力（カジュアル）:
「バグ見つけたんで、直しました。テストもOKです。」

改善版（フォーマル）:
「プログラムの不具合を特定し、修正を完了いたしました。
単体テストおよび結合テストにより、修正内容の妥当性を確認済みです。」
```

#### カジュアル（ブログ記事）

```
AI初期出力（硬い）:
「本プロトコルにおいては、クライアント・サーバー間の通信を
実現するために、HTTP/2を採用している。」

改善版（カジュアル）:
「このアプリでは、クライアントとサーバーの通信にHTTP/2を使ってます。
従来のHTTP/1.1より速いんですよ！」
```

#### 技術的（ドキュメント）

```
AI初期出力（一般向け）:
「このプログラムは速いです。」

改善版（技術的）:
「このアルゴリズムは時間計算量O(n log n)で動作し、
平均的なケースで優れたパフォーマンスを発揮します。
空間計算量はO(log n)で、in-placeソートに近い効率性を実現しています。」
```

### 7. 専門性向上

#### Before: 表面的

```
AI初期出力:
「Reactは仮想DOMを使っているので速いです。」
```

#### After: 専門的

```
改善版:
# Reactの仮想DOMによるパフォーマンス最適化

## 仮想DOMの仕組み

Reactは仮想DOM（Virtual DOM）という軽量なDOM表現をメモリ上に保持します。
状態が変更されると、以下のプロセスで効率的に更新を行います：

1. **Reconciliation（差分検出）**
   - 新しい仮想DOMツリーを構築
   - 前の仮想DOMツリーと比較（Diffingアルゴリズム）
   - 変更が必要な最小限のノードを特定

2. **Batch Update（バッチ更新）**
   - 複数の状態変更を1回のDOM操作にまとめる
   - レイアウトの再計算回数を削減

3. **Commit Phase**
   - 実際のDOMへの変更を適用
   - ブラウザの再レンダリングをトリガー

## パフォーマンスの利点

- **DOM操作の最小化**: O(n³) → O(n)の差分検出
- **バッチ処理**: 複数の更新を1回で実行
- **非同期レンダリング**: React 18のConcurrent Rendering

## 注意点

仮想DOMは常に高速とは限りません：
- 小規模な変更では、オーバーヘッドが発生する場合あり
- 適切なメモ化（`React.memo`, `useMemo`）が重要
```

**改善ポイント**:
- 技術的な詳細を追加
- アルゴリズムの説明
- 計算量の明記
- 制約・注意点も記載

### 8. 読みやすさ改善

#### Before: 読みにくい

```
AI初期出力:
「エラーハンドリングはtry-catchを使います。catchブロックでエラーを
キャッチして、ログに出力して、ユーザーにメッセージを表示します。
finallyブロックでリソースをクリーンアップします。」
```

#### After: 読みやすい

```
改善版:
# エラーハンドリングのベストプラクティス

## 基本構造

```javascript
try {
  // エラーが発生する可能性のある処理
  const data = await fetchData();
  processData(data);

} catch (error) {
  // エラーハンドリング
  console.error('エラー:', error);
  showErrorMessage('データの取得に失敗しました');

} finally {
  // リソースのクリーンアップ（常に実行）
  closeConnection();
}
```

## 実行フロー

1. **Try ブロック**: 通常の処理を実行
2. **Catch ブロック**: エラー発生時に実行
   - エラーログの記録
   - ユーザーへの通知
3. **Finally ブロック**: 成功・失敗に関わらず実行
   - リソースの解放
   - 後処理
```

**改善ポイント**:
- コード例で視覚的に理解
- ステップバイステップの説明
- 見出しで構造化

### 9. 例の追加

#### Before: 抽象的

```
AI初期出力:
「Promiseは非同期処理を扱うためのオブジェクトです。」
```

#### After: 具体例付き

```
改善版:
# JavaScript Promise入門

## 概要
Promiseは非同期処理を扱うためのオブジェクトで、処理の完了・失敗を表現します。

## 基本的な使い方

### 例1: API呼び出し

```javascript
// Promiseを返す関数
function fetchUser(userId) {
  return fetch(`/api/users/${userId}`)
    .then(response => response.json())
    .then(data => data.user);
}

// 使用例
fetchUser(123)
  .then(user => console.log('ユーザー:', user))
  .catch(error => console.error('エラー:', error));
```

### 例2: 複数の非同期処理

```javascript
// 並列実行
Promise.all([
  fetchUser(1),
  fetchUser(2),
  fetchUser(3)
])
  .then(users => {
    console.log('全ユーザー:', users);
  });

// 順次実行
async function processUsers() {
  const user1 = await fetchUser(1);
  const user2 = await fetchUser(2);
  console.log(user1, user2);
}
```

### 例3: エラーハンドリング

```javascript
fetchUser(999)
  .then(user => {
    if (!user) {
      throw new Error('ユーザーが見つかりません');
    }
    return user;
  })
  .catch(error => {
    console.error('処理失敗:', error.message);
    return null; // デフォルト値
  });
```

## よくあるパターン

| パターン | 用途 | 例 |
|---------|------|-----|
| Promise.all | 並列実行（全て成功） | 複数APIの同時呼び出し |
| Promise.race | 最速の結果を採用 | タイムアウト処理 |
| Promise.allSettled | 並列実行（成功/失敗問わず） | ベストエフォート処理 |
```

**改善ポイント**:
- 複数の具体例
- ユースケース別の説明
- 表による比較

### 10. 対象読者最適化

#### 初心者向け

```
「React Hooksは、関数コンポーネントで状態管理ができる便利な機能です。

**一番よく使う Hook: useState**

```javascript
import { useState } from 'react';

function Counter() {
  // カウンターの値を保持する
  const [count, setCount] = useState(0);

  return (
    <div>
      <p>現在のカウント: {count}</p>
      <button onClick={() => setCount(count + 1)}>
        +1
      </button>
    </div>
  );
}
```

**ポイント**:
- `useState(0)` で初期値を0に設定
- `count` で現在の値を取得
- `setCount()` で値を更新
```

#### 上級者向け

```
「React Hooksの内部実装とパフォーマンス最適化」

## Hooksの実装原理

Reactは内部でFiberアーキテクチャを使用し、各コンポーネントインスタンスに
hookのリンクリストを保持します。

```javascript
// 簡略化した内部表現
type Hook = {
  memoizedState: any;
  next: Hook | null;
};

// Fiber node
type Fiber = {
  memoizedState: Hook | null;
  // ...
};
```

## パフォーマンス最適化

### 1. useCallback のメモ化

```javascript
const memoizedCallback = useCallback(
  () => {
    doSomething(a, b);
  },
  [a, b] // 依存配列
);
```

内部的には、依存配列が変更されない限り、同じ関数参照を返却します。

### 2. useMemo の最適化ポイント

```javascript
const expensiveValue = useMemo(() => {
  return computeExpensiveValue(a, b);
}, [a, b]);
```

**注意**: メモ化自体にもコストがあるため、以下の場合のみ使用を推奨：
- 計算コストが高い（>50ms）
- 子コンポーネントへのprops（参照の一貫性が必要）
```

## 改善プロセス

### ステップ1: 初期分析

```
入力: AI初期出力

分析項目:
- 文章の流暢性
- 構造の有無
- 情報の完全性
- 対象読者の明確性
- 専門性のレベル

出力: 改善ポイントリスト
```

### ステップ2: 改善計画

```
優先順位付け:
1. 重大な誤り・不足の修正
2. 構造化
3. 明確化・詳細化
4. 文章の洗練
5. 例の追加
```

### ステップ3: 改善実行

```
各改善項目を適用:
- 文章の書き換え
- 見出しの追加
- コード例の挿入
- 説明の補完
```

### ステップ4: 品質確認

```
チェック項目:
✓ 情報の正確性
✓ 論理的な流れ
✓ 読みやすさ
✓ 対象読者への適合性
✓ 完全性
```

## 使用例

### 基本的な改善

```
以下のAI出力を改善してください：

「Reactは便利です。使いやすいです。人気があります。」

改善方針:
- 文章を流暢に
- 具体的な理由を追加
- 構造化
```

### トーン調整

```
以下の技術説明をブログ記事風にカジュアルに書き換えてください：

「本システムにおいては、マイクロサービスアーキテクチャを採用することにより、
スケーラビリティの向上を実現している。」

対象読者: 一般の開発者
トーン: フレンドリー、親しみやすい
```

### 対象読者最適化

```
以下の説明を初心者向けに書き換えてください：

「async/awaitはPromiseのシンタックスシュガーであり、
非同期処理をシーケンシャルなコードのように記述可能にする。」

対象: プログラミング初学者（JavaScript基礎は理解）
改善方針:
- 専門用語を平易に
- 具体例を追加
- ステップバイステップの説明
```

### 詳細化

```
以下の不完全な説明を詳細化してください：

「Dockerfileを作成して、イメージをビルドします。」

追加すべき内容:
- Dockerfileの具体的な内容
- ビルドコマンド
- 実行方法
- トラブルシューティング
```

## ベストプラクティス

1. **原文の意図を保持**: 改善しても元の意味を変えない
2. **過度な装飾を避ける**: 必要な情報を明確に
3. **対象読者を常に意識**: 知識レベルに合わせた表現
4. **具体例を活用**: 抽象的な説明には例を追加
5. **構造化**: 見出し、箇条書きで読みやすく
6. **バランス**: 詳細すぎず、簡潔すぎず
7. **一貫性**: トーン、用語の使用を統一

## バージョン情報

- スキルバージョン: 1.0.0
- 最終更新: 2025-11-22

---

## 使用例まとめ

### シンプルな改善

```
この文章を改善してください：
[粗い出力]
```

### 詳細な改善

```
以下のAI出力を改善してください：
[テキスト]

改善方針:
- 文章の流暢性
- 構造化
- 詳細化
- トーン: フォーマル
- 対象: 初心者
```

このスキルで、AI出力を洗練された高品質な応答に変換しましょう！
