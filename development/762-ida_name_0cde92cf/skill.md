# ida_name

Functions that deal with names.

A non-tail address of the program may have a name. Tail addresses (i.e. the addresses in the middle of an instruction or data item) cannot have names.

## Constants

- `MAXNAMELEN`: Maximum length of a name in IDA (with the trailing zero)
- `FUNC_IMPORT_PREFIX`: Name prefix used by IDA for the imported functions.
- `SN_CHECK`: Fail if the name contains invalid characters.
- `SN_NOCHECK`: Replace invalid characters silently. If this bit is set, all invalid chars (not in NameChars or MangleChars) will be replaced by '_' List of valid characters is defined in ida.cfg
- `SN_PUBLIC`: if set, make name public
- `SN_NON_PUBLIC`: if set, make name non-public
- `SN_WEAK`: if set, make name weak
- `SN_NON_WEAK`: if set, make name non-weak
- `SN_AUTO`: if set, make name autogenerated
- `SN_NON_AUTO`: if set, make name non-autogenerated
- `SN_NOLIST`: if set, exclude name from the list. if not set, then include the name into the list (however, if other bits are set, the name might be immediately excluded from the list).
- `SN_NOWARN`: don't display a warning if failed
- `SN_LOCAL`: create local name. a function should exist. local names can't be public or weak. also they are not included into the list of names they can't have dummy prefixes.
- `SN_IDBENC`: the name is given in the IDB encoding; non-ASCII bytes will be decoded accordingly. Specifying SN_IDBENC also implies SN_NODUMMY
- `SN_FORCE`: if the specified name is already present in the database, try variations with a numerical suffix like "_123"
- `SN_NODUMMY`: automatically prepend the name with '_' if it begins with a dummy suffix such as 'sub_'. See also SN_IDBENC
- `SN_DELTAIL`: if name cannot be set because of a tail byte, delete the hindering item
- `SN_MULTI`: if the specified address already has a name, then add the new name as a regular comment "Alternative name is ...". Except when the new name is public and the old one is not or when the old name is weak and the new one is not. In these cases we act as if bit SN_MULTI_FORCE is specified. If the new name only slightly differs from the old one, for example, only by the initial underscore or the artificial suffix '_##', then we ignore it.
- `SN_MULTI_FORCE`: if the specified address already has a name, put this old name into a regular comment and set the specified name. This bit may be used only with SN_MULTI.
- `UCDR_STRLIT`: string literals
- `UCDR_NAME`: regular (unmangled) names
- `UCDR_MANGLED`: mangled names
- `UCDR_TYPE`: type names
- `VNT_IDENT`: identifier (e.g., function name)
- `VNT_TYPE`: type name (can contain '<', '>', ...)
- `VNT_UDTMEM`: UDT (structure, union, enum) member.
- `VNT_STRLIT`: string literal
- `VNT_VISIBLE`: visible cp (obsolete; will be deleted)
- `NT_NONE`: name doesn't exist or has no value
- `NT_BYTE`: name is byte name (regular name)
- `NT_LOCAL`: name is local label
- `NT_STKVAR`: name is stack variable name
- `NT_ENUM`: name is symbolic constant
- `NT_ABS`: name is absolute symbol (SEG_ABSSYM)
- `NT_SEG`: name is segment or segment register name
- `NT_STROFF`: name is structure member
- `NT_BMASK`: name is a bit group mask name
- `NT_REGVAR`: name is a renamed register (*value is idx into pfn->regvars)
- `GN_VISIBLE`: replace forbidden characters by SUBSTCHAR
- `GN_COLORED`: return colored name
- `GN_DEMANGLED`: return demangled name
- `GN_STRICT`: fail if cannot demangle
- `GN_SHORT`: use short form of demangled name
- `GN_LONG`: use long form of demangled name
- `GN_LOCAL`: try to get local name first; if failed, get global
- `GN_ISRET`: for dummy names: use retloc
- `GN_NOT_ISRET`: for dummy names: do not use retloc
- `GN_NOT_DUMMY`: do not return a dummy name
- `GETN_APPZERO`: meaningful only if the name refers to a structure. append a struct field name if the field offset is zero?
- `GETN_NOFIXUP`: ignore the fixup information when producing the name
- `GETN_NODUMMY`: do not create a new dummy name but pretend it exists
- `GNCN_NOSEG`: ignore the segment prefix when producing the name
- `GNCN_NOCOLOR`: generate an uncolored name
- `GNCN_NOLABEL`: don't generate labels
- `GNCN_NOFUNC`: don't generate funcname+... expressions
- `GNCN_SEG_FUNC`: generate both segment and function names (default is to omit segment name if a function name is present)
- `GNCN_SEGNUM`: segment part is displayed as a hex number
- `GNCN_REQFUNC`: return 0 if the address does not belong to a function
- `GNCN_REQNAME`: return 0 if the address can only be represented as a hex number
- `GNCN_NODBGNM`: don't use debug names
- `GNCN_PREFDBG`: if using debug names, prefer debug names over function names
- `DEBNAME_EXACT`: find a name at exactly the specified address
- `DEBNAME_LOWER`: find a name with the address >= the specified address
- `DEBNAME_UPPER`: find a name with the address > the specified address
- `DEBNAME_NICE`: find a name with the address <= the specified address
- `DQT_NPURGED_8`: only calculate number of purged bytes (sizeof(arg)==8)
- `DQT_NPURGED_4`: only calculate number of purged bytes (sizeof(arg)==4)
- `DQT_NPURGED_2`: only calculate number of purged bytes (sizeof(arg)==2)
- `DQT_COMPILER`: only detect compiler that generated the name
- `DQT_NAME_TYPE`: only detect the name type (data/code)
- `DQT_FULL`: really demangle
- `CN_KEEP_TRAILING_DIGITS`: do not remove "_d+" at the end of name
- `CN_KEEP_UNDERSCORES`: do not remove leading underscores. but it is ok to remove __imp_.
- `ME_INTERR`
- `ME_PARAMERR`
- `ME_ILLSTR`
- `ME_SMALLANS`
- `ME_FRAME`
- `ME_NOCOMP`
- `ME_ERRAUTO`
- `ME_NOHASHMEM`
- `ME_NOSTRMEM`
- `ME_NOERROR_LIMIT`
- `M_PRCMSK`
- `MT_DEFAULT`
- `MT_CDECL`
- `MT_PASCAL`
- `MT_STDCALL`
- `MT_FASTCALL`
- `MT_THISCALL`
- `MT_FORTRAN`
- `MT_SYSCALL`
- `MT_INTERRUPT`
- `MT_MSFASTCALL`
- `MT_CLRCALL`
- `MT_DMDCALL`
- `MT_VECTORCALL`
- `MT_REGCALL`
- `MT_LOCALNAME`
- `M_SAVEREGS`
- `M_CLASS`
- `MT_PUBLIC`
- `MT_PRIVATE`
- `MT_PROTECT`
- `MT_MEMBER`
- `MT_VTABLE`
- `MT_RTTI`
- `M_PARMSK`
- `MT_PARSHF`
- `MT_PARMAX`
- `M_ELLIPSIS`
- `MT_VOIDARG`
- `M_STATIC`
- `M_VIRTUAL`
- `M_AUTOCRT`
- `M_TYPMASK`
- `MT_OPERAT`
- `MT_CONSTR`
- `MT_DESTR`
- `MT_CASTING`
- `MT_CLRCDTOR`
- `M_TRUNCATE`
- `M_THUNK`
- `M_ANONNSP`
- `M_TMPLNAM`
- `M_DBGNAME`
- `M_COMPILER`
- `MT_MSCOMP`
- `MT_BORLAN`
- `MT_WATCOM`
- `MT_OTHER`
- `MT_GNU`
- `MT_GCC3`
- `MT_VISAGE`
- `MNG_PTRMSK`
- `MNG_DEFNEAR`
- `MNG_DEFNEARANY`
- `MNG_DEFFAR`
- `MNG_NOPTRTYP16`
- `MNG_DEFHUGE`
- `MNG_DEFPTR64`
- `MNG_DEFNONE`
- `MNG_NOPTRTYP`
- `MNG_NODEFINIT`
- `MNG_NOUNDERSCORE`
- `MNG_NOTYPE`
- `MNG_NORETTYPE`
- `MNG_NOBASEDT`
- `MNG_NOCALLC`
- `MNG_NOPOSTFC`
- `MNG_NOSCTYP`
- `MNG_NOTHROW`
- `MNG_NOSTVIR`
- `MNG_NOECSU`
- `MNG_NOCSVOL`
- `MNG_NOCLOSUR`
- `MNG_NOUNALG`
- `MNG_NOMANAGE`
- `MNG_NOMODULE`
- `MNG_SHORT_S`
- `MNG_SHORT_U`
- `MNG_ZPT_SPACE`
- `MNG_DROP_IMP`
- `MNG_IGN_ANYWAY`
- `MNG_IGN_JMP`
- `MNG_MOVE_JMP`
- `MNG_COMPILER_MSK`
- `MNG_SHORT_FORM`
- `MNG_LONG_FORM`
- `MNG_CALC_VALID`
- `cvar`
- `ignore_none`
- `ignore_regvar`
- `ignore_llabel`
- `ignore_stkvar`
- `ignore_glabel`
- `MANGLED_CODE`
- `MANGLED_DATA`
- `MANGLED_UNKNOWN`

## Classes Overview

- `ea_name_vec_t`
- `ea_name_t`
- `NearestName`: Utility class to help find the nearest name in a given ea/name dictionary

## Functions Overview

- `get_name(ea: ida_idaapi.ea_t) -> str`
- `get_colored_name(ea: ida_idaapi.ea_t) -> str`
- `set_name(ea: ida_idaapi.ea_t, name: str, flags: int = 0) -> bool`: Set or delete name of an item at the specified address. An item can be anything: instruction, function, data byte, word, string, structure, etc... Include name into the list of names.
- `force_name(ea: ida_idaapi.ea_t, name: str, flags: int = 0) -> bool`
- `del_global_name(ea: ida_idaapi.ea_t) -> bool`
- `del_local_name(ea: ida_idaapi.ea_t) -> bool`
- `set_dummy_name(_from: ida_idaapi.ea_t, ea: ida_idaapi.ea_t) -> bool`: Give an autogenerated (dummy) name. Autogenerated names have special prefixes (loc_...).
- `make_name_auto(ea: ida_idaapi.ea_t) -> bool`
- `make_name_user(ea: ida_idaapi.ea_t) -> bool`
- `is_valid_cp(cp: wchar32_t, kind: nametype_t, data: void * = None) -> bool`: Is the given codepoint acceptable in the given context?
- `set_cp_validity(*args) -> None`: Mark the given codepoint (or range) as acceptable or unacceptable in the given context If 'endcp' is not BADCP, it is considered to be the end of the range: [cp, endcp), and is not included in the range
- `get_cp_validity(*args) -> bool`: Is the given codepoint (or range) acceptable in the given context? If 'endcp' is not BADCP, it is considered to be the end of the range: [cp, endcp), and is not included in the range
- `is_ident_cp(cp: wchar32_t) -> bool`: Can a character appear in a name? (present in ::NameChars or ::MangleChars)
- `is_strlit_cp(cp: wchar32_t, specific_ranges: rangeset_crefvec_t const * = None) -> bool`: Can a character appear in a string literal (present in ::StrlitChars) If 'specific_ranges' are specified, those will be used instead of the ones corresponding to the current culture (only if ::StrlitChars is configured to use the current culture)
- `is_visible_cp(cp: wchar32_t) -> bool`: Can a character be displayed in a name? (present in ::NameChars)
- `is_ident(name: str) -> bool`: Is a valid name? (including ::MangleChars)
- `is_uname(name: str) -> bool`: Is valid user-specified name? (valid name & !dummy prefix).
- `is_valid_typename(name: str) -> bool`: Is valid type name?
- `extract_name(line: str, x: int) -> str`: Extract a name or address from the specified string.
- `hide_name(ea: ida_idaapi.ea_t) -> None`: Remove name from the list of names
- `show_name(ea: ida_idaapi.ea_t) -> None`: Insert name to the list of names.
- `get_name_ea(_from: ida_idaapi.ea_t, name: str) -> ida_idaapi.ea_t`: Get the address of a name. This function resolves a name into an address. It can handle regular global and local names, as well as debugger names.
- `get_name_base_ea(_from: ida_idaapi.ea_t, to: ida_idaapi.ea_t) -> ida_idaapi.ea_t`: Get address of the name used in the expression for the address
- `get_name_value(_from: ida_idaapi.ea_t, name: str) -> uval_t *`: Get value of the name. This function knows about: regular names, enums, special segments, etc.
- `get_visible_name(ea: ida_idaapi.ea_t, gtn_flags: int = 0) -> str`
- `get_short_name(ea: ida_idaapi.ea_t, gtn_flags: int = 0) -> str`
- `get_long_name(ea: ida_idaapi.ea_t, gtn_flags: int = 0) -> str`
- `get_colored_short_name(ea: ida_idaapi.ea_t, gtn_flags: int = 0) -> str`
- `get_colored_long_name(ea: ida_idaapi.ea_t, gtn_flags: int = 0) -> str`
- `get_demangled_name(ea: ida_idaapi.ea_t, inhibitor: int, demform: int, gtn_flags: int = 0) -> str`
- `get_colored_demangled_name(ea: ida_idaapi.ea_t, inhibitor: int, demform: int, gtn_flags: int = 0) -> str`
- `get_name_color(_from: ida_idaapi.ea_t, ea: ida_idaapi.ea_t) -> color_t`: Calculate flags for get_ea_name() function.
- `get_name_expr(_from: ida_idaapi.ea_t, n: int, ea: ida_idaapi.ea_t, off: int, flags: int = 1) -> str`: Convert address to name expression (name with a displacement). This function takes into account fixup information and returns a colored name expression (in the form <name> +/- <offset>). It also knows about structure members and arrays. If the specified address doesn't have a name, a dummy name is generated.
- `get_nice_colored_name(ea: ida_idaapi.ea_t, flags: int = 0) -> str`: Get a nice colored name at the specified address. Ex:
- `append_struct_fields(disp: adiff_t *, n: int, path: tid_t const *, flags: flags64_t, delta: adiff_t, appzero: bool) -> str`: Append names of struct fields to a name if the name is a struct name.
- `is_public_name(ea: ida_idaapi.ea_t) -> bool`
- `make_name_public(ea: ida_idaapi.ea_t) -> None`
- `make_name_non_public(ea: ida_idaapi.ea_t) -> None`
- `is_weak_name(ea: ida_idaapi.ea_t) -> bool`
- `make_name_weak(ea: ida_idaapi.ea_t) -> None`
- `make_name_non_weak(ea: ida_idaapi.ea_t) -> None`
- `get_nlist_size() -> size_t`
- `get_nlist_idx(ea: ida_idaapi.ea_t) -> size_t`
- `is_in_nlist(ea: ida_idaapi.ea_t) -> bool`
- `get_nlist_ea(idx: size_t) -> ida_idaapi.ea_t`
- `get_nlist_name(idx: size_t) -> str`
- `rebuild_nlist() -> None`
- `reorder_dummy_names() -> None`: Renumber dummy names.
- `set_debug_name(ea: ida_idaapi.ea_t, name: str) -> bool`
- `get_debug_name(ea_ptr: ea_t *, how: debug_name_how_t) -> str`
- `del_debug_names(ea1: ida_idaapi.ea_t, ea2: ida_idaapi.ea_t) -> None`
- `get_debug_name_ea(name: str) -> ida_idaapi.ea_t`
- `demangle_name(name: str, disable_mask: int, demreq: demreq_type_t = DQT_FULL) -> str`: Demangle a name.
- `is_name_defined_locally(*args) -> bool`: Is the name defined locally in the specified function?
- `cleanup_name(ea: ida_idaapi.ea_t, name: str, flags: int = 0) -> str`
- `get_mangled_name_type(name: str) -> mangled_name_type_t`
- `get_debug_names(*args) -> PyObject *`
- `get_ea_name(ea: ida_idaapi.ea_t, gtn_flags: int = 0) -> str`: Get name at the specified address.
- `validate_name(name: str, type: nametype_t, flags: int = 1) -> PyObject *`: Validate a name. If SN_NOCHECK is specified, this function replaces all invalid characters in the name with SUBSTCHAR. However, it will return false if name is valid but not allowed to be an identifier (is a register name).
- `calc_gtn_flags(fromaddr, ea)`: Calculate flags for get_ea_name() function